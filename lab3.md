#一、实验步骤
####1、将teacher盘上的Deadlock.java文件拷贝到ubuntu中的任意文件夹中区保存，然后将多次运行的代码：
 !/bin/bash

    for ((c=1;c<=100;c++))

       do

       echo "$c times"

    java Deadlock

    done
写到一个新建的文件（Untitled Document）中；

![](http://p1.bpimg.com/567571/b72b2e601c7c2948.png)
![](http://p1.bpimg.com/567571/7fc09c56841d5bec.png)
![](http://p1.bpimg.com/567571/982b1a9383140243.png)

####2、在命令行中输入：

#####1、javac Deadlock.java
这样就会产生类文件，最后让这个文件连续运行100次：

#####2、./Untitled\ Document
通过不断更改count的值达到死锁的状态产生死锁后截图：注意修改了count值之后需要重新生成class文件，即是重新运行javac Deadlock.java和./Untitled\ Document

#二、实验结果

![](http://p1.bpimg.com/567571/f2b18eaa8932b625.png)

![](http://p1.bpimg.com/567571/f1cad5926078c3c5.png)

#三、实验思考
##1、产生死锁的4个必要条件：

1、占有且等待

2、资源互斥
  
3、资源不可剥夺

4、循环等待

##2、上述程序产生死锁的原因：

![](http://i1.piimg.com/567571/1e9a1df4655a9f69.png)

通过查看该java文件可以得知类A需要b的资源，类B需要a的资源，他们一起运行，彼此占据着资源，类A在等待类B执行完之后拿到资源，类B在等待类A执行完之后拿到资源，加上后面的循环100次的文件，即是这样循环等待运行了100次，符合产生死锁的四个必要条件，此时只要通过修改count让类A与类B几乎同时运行的时候就会发生死锁:

![](http://p1.bpimg.com/567571/51db55c2fcc80e5e.png)

具体调整count大小的时候可以根据二分法，通过观察运行结果中哪个类跑在前面或者哪个类跑在前面的次数多少来决定取大值还是小值，最终得到一个合适的值让死锁发生；注意死锁发生的情况每个电脑不一样，每一次实验也不一样。

##3、本次实验收获：

在上学期上操作系统的时候就知道了线程之间可能会因为某些原因发生死锁，现在的实验课上通过自己调整count的值让自己对于死锁产生的情况有了更加深入的了解：死锁就是两个或者多个进程，互相请求对方占有的资源：指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

因为觉得每次修改dol中的文件的时候都会需要使用超级权限sudo，因此就直接将该文件解锁了，直接可以在里面新建文档修改文档：
![](http://i1.piimg.com/567571/4acbb8a125808124.png)

并且每次在命令行中运行指令的时候都需要注意到当前文件的目录下去执行，否则就会报错说找不到该文件。
